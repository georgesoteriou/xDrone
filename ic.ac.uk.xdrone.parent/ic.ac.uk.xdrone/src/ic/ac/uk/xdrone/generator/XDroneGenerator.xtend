/*
 * generated by Xtext 2.17.0
 */
package ic.ac.uk.xdrone.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ic.ac.uk.xdrone.xDrone.Fly
import ic.ac.uk.xdrone.xDrone.Command
import ic.ac.uk.xdrone.xDrone.Up
import ic.ac.uk.xdrone.xDrone.Left
import ic.ac.uk.xdrone.xDrone.Right
import ic.ac.uk.xdrone.xDrone.Wait
import ic.ac.uk.xdrone.xDrone.Down
import java.io.PrintWriter
import java.io.IOException
import java.io.File
import ic.ac.uk.xdrone.xDrone.Environment
import ic.ac.uk.xdrone.xDrone.Drone
import ic.ac.uk.xdrone.xDrone.Main
import ic.ac.uk.xdrone.xDrone.GoTo
import ic.ac.uk.xdrone.xDrone.Forward
import ic.ac.uk.xdrone.xDrone.Backward
import ic.ac.uk.xdrone.xDrone.RotateL
import ic.ac.uk.xdrone.xDrone.RotateR

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class XDroneGenerator extends AbstractGenerator {

	def compile(Environment environment)'''
	function environment()
	{
		//resets drone location
		drone.position.x = 0;
		drone.position.z = 0;
		drone.position.y = 0 + modelHeight;
		«FOR d : environment.drone»
			drone.position.x = «d.position.vector.x»
			drone.position.z = «d.position.vector.z»
			drone.position.y = «d.position.vector.y» + modelHeight
			«IF d.rotation !== null»
				currentDroneAngle += «d.rotation»;
				drone.rotateY(«d.rotation»  * (Math.PI/180));
			«ENDIF»
		«ENDFOR»
		«FOR d : environment.walls»
			drawWalls(«d.front.value», «d.right.value», «d.back.value», «d.left.value»,  «d.up.value»)
		«ENDFOR»
		«FOR ob : environment.objects»
			addCube("«ob.object_name»",«ob.size.vector.x», «ob.size.vector.y», «ob.size.vector.z», 
				«ob.origin.vector.x», «ob.origin.vector.y», «ob.origin.vector.z»,
			«IF ob.color !== null»
				"«ob.color.color_value»"
			«ENDIF»
			)
		«ENDFOR»
	}
	'''
	
	def compileJS(Fly fly)'''
		var ANGLE_MARIGIN = 0.4;
		var MOVE_MARIGIN = 1.25;
		var MOVE_MARIGIN_ADD = 0.6;
		var MOVE_MARIGIN_NEXT = 0.95;
		var MOVE_MARIGIN_NEXT_ADD = 0.1;
		
		
		var commands = [];
		var currentDroneLocation = {x: drone.position.x, y: drone.position.y, z: drone.position.z};
		var goalDroneRotation = drone.rotation.y;
		var currentFunction = "";
		var finishSimulation = false;
		var destination = 0;

		//Drone's path
		var lineMaterial = new THREE.LineBasicMaterial({color: 0x1ACF10});
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push(
			new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z)
		);
		«FOR to : fly.takeoff»
			commands.push("TAKEOFF");
		«ENDFOR»
		
		«FOR f : fly.commands»
			«IF f instanceof Command»
				«f.compileJS»
			«ENDIF»
		«ENDFOR»	
		
		«FOR to : fly.land»
			commands.push("LAND");
		«ENDFOR»
		nextCommand();
		
		if(line)
			scene.remove( line );
		line = new THREE.Line( lineGeometry, lineMaterial );
		scene.add( line );
		
		//Function which is called by simultor and execute flying comands one by one
		function flySimulation(){
			if(!finishSimulation){
				if((currentFunction == "MOVE_Y" && fly(destination, 'y'))
					|| (currentFunction == "MOVE_X" && fly(destination, 'x'))
					|| (currentFunction == "MOVE_Z" && fly(destination, 'z'))
					|| (currentFunction == "LAND" && land())
					|| (currentFunction == "ROTATION" && rotation(goalDroneRotation))){
					nextCommand();
				}
			}
		}
		
		//Returns appropriate commadns based on array entry
		function nextCommand(){
			if(commands && commands[0]){
				if(commands[0].r !== undefined){
					changeDroneCollisionBox(getDistanceErrorFromAngle(commands[0].r),0,getDistanceErrorFromAngle(commands[0].r))
					goalDroneRotation = commands[0].r * (Math.PI/180);
					currentFunction = "ROTATION";
				}
				else if(commands[0].w !== undefined){
					execute = false;
					setTimeout(function () {
						execute = true;
					    }, (commands[0].w * 1000));
				}
				else if(commands[0].y !== undefined){
					destination = commands[0].y;
					currentFunction = "MOVE_Y";
					lineGeometry.vertices.push(new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z))
				}
				else if(commands[0].x !== undefined){
					changeDroneCollisionBox(getDistanceErrorFromDistance(Math.abs(commands[0].x)),0,0)
					destination = commands[0].x;
					currentFunction = "MOVE_X";
					lineGeometry.vertices.push(new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z))
				}
				else if(commands[0].z !== undefined){
					changeDroneCollisionBox(0, 0, getDistanceErrorFromDistance(Math.abs(commands[0].z)))
					destination = commands[0].z;
					currentFunction = "MOVE_Z";
					lineGeometry.vertices.push(new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z))
				}
				else if(commands[0] == "TAKEOFF"){
					//changeDroneCollisionBox(0.25,0,0.25)
					destination = 0.7;
					currentFunction = "MOVE_Y";
					lineGeometry.vertices.push(new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z))
				}
				else if(commands[0] == "LAND"){
					//changeDroneCollisionBox(0.25,0,0.25)
					currentFunction = "LAND";
					lineGeometry.vertices.push(new THREE.Vector3( drone.position.x, drone.position.y, drone.position.z))
				}
				else if(commands[0].flyTo !== undefined){
					var vector = getDistanceToObject(commands[0].flyTo);
					var angle = getRotationToObject(commands[0].flyTo);
										
					var commandSet = "";
					
					if(angle > 0)
						commandSet += "ROTATELEFT(" + Math.round( Math.abs(angle) * 10) / 10 + ")\n";
					else if(angle < 0)
						commandSet += "ROTATERIGHT(" + Math.round( Math.abs(angle) * 10) / 10 + ")\n";
					if(vector.y > 0)
						commandSet += "UP(" + Math.round( Math.abs(vector.y) * 10) / 10 + ")\n";
					else if(vector.y < 0)
						commandSet += "DOWN(" + Math.round( Math.abs(vector.y) * 10) / 10 + ")\n";
					if(vector.z > 0)
						commandSet += "FORWARD(" + Math.round( vector.z * 10) / 10 + ")\n";
										
					listGoTo.push({object_name: commands[0].flyTo, 
					commands: commandSet});
					console.log(listGoTo)
					lastFirstNumber = "-1"; //Force refresh
						
					commands.shift();
					
					changeDroneCollisionBox(getDistanceErrorFromAngle(angle),0,getDistanceErrorFromAngle(angle))
					
					goalDroneRotation = angle * (Math.PI/180);
					currentFunction = "ROTATION";
					commands.unshift({z: vector.z}); 
					commands.unshift({y: vector.y}); 
					commands.unshift({r: angle});
				}
				commands.shift();
			}
			else{
				finishSimulation = true;
			}
		}
		
		//Calcualtes the distance margin error caused by rotating the drone
		function getDistanceErrorFromAngle(angle){
			return ANGLE_MARIGIN * Math.abs(angle) /90
		}
		
		//Calcualtes the distance margin error caused by movement of the drone
		function getDistanceErrorFromDistance(distance){
			if(distance < MOVE_MARIGIN)
				return MOVE_MARIGIN_ADD;
			else
				return MOVE_MARIGIN_ADD + (((distance-MOVE_MARIGIN) * MOVE_MARIGIN_NEXT_ADD) / MOVE_MARIGIN_NEXT)
		}
	'''
	
	def compileJS(Command cmd) '''
«IF cmd instanceof Up »
		commands.push({y: «cmd.distance»}); 
	  	«ENDIF»
	  	«IF cmd instanceof Down»
commands.push({y: -«cmd.distance»}); 
	  	«ENDIF»
	  	«IF cmd instanceof Left »
commands.push({x: «cmd.distance»});
	  	«ENDIF»
	  	«IF cmd instanceof Right»
commands.push({x: -«cmd.distance»});
	  	«ENDIF»
	  	«IF cmd instanceof Forward»	
commands.push({z: «cmd.distance»});
	  	«ENDIF»
	  	«IF cmd instanceof Backward»
commands.push({z: -«cmd.distance»});
	  	«ENDIF»
	  	«IF cmd instanceof RotateL»
			commands.push({r: «cmd.angle»}); 
	  	«ENDIF»
	  	«IF cmd instanceof RotateR»
			commands.push({r: -«cmd.angle»}); 
	  	«ENDIF»
	  	«IF cmd instanceof Wait»
			commands.push({w: «cmd.seconds»});
	  	«ENDIF»
	  	«IF cmd instanceof GoTo»
			commands.push({flyTo: "«cmd.object_name»"});
	  	«ENDIF»
	'''
	

	def compilePython(Main main)'''
		#! /usr/bin/env python
		import sys
		import math  
		from pyparrot.Minidrone import Mambo
		
		PI = 3.1415926535897
		#Constants
		ACCEPTED_DISTANCE_ERROR = 20 # 20 cm
		ACCEPTED_ALTITUDE_ERROR = 50 # 5 cm
		ACCEPTED_ROTATION_ERROR = 10 # 10 degrees
		DISTANCE_ONE_AND_HALF_SECOND = 1.25
		DISTANCE_TWO_SECONDS = 2.20
		
		dronePosition = {
			'x': 0,
			'y': 0,
			'z': 0
		}
		currentDroneAngle = 270.0 #Real Life
		
		#maps drone's position
		«IF main.environment !== null»
			«FOR d : main.environment.drone»
				«IF d.position !== null»
					dronePosition.x = «d.position.vector.z»
					dronePosition.z = «d.position.vector.y»
					dronePosition.y = «d.position.vector.x»
				«ENDIF»
				«IF d.rotation !== null»
					currentDroneAngle += «d.rotation»
				«ENDIF»
			«ENDFOR»
		«ENDIF»
		
		objects = {}
		
		#maps all objects
		«IF main.environment !== null»
			«FOR ob : main.environment.objects»
				«IF ob.origin !== null»
					«IF ob.size !== null»
						objects['«ob.object_name»'] = {
							'x': «ob.origin.vector.z»,
							'y': «ob.origin.vector.x»,
							'z': «ob.origin.vector.y» + «ob.size.vector.y»/2
						}
					«ENDIF»
				«ENDIF»
			«ENDFOR»
		«ENDIF»
		
		#RotY:		RotX:
		#+ forward 	+ right
		#- backwards	- left
		
		#Returns time that drone should fly to reach travel given distance
		def getTimeFromDistance(distance):
			global DISTANCE_ONE_AND_HALF_SECOND
			global DISTANCE_TWO_SECONDS
			global DISTANCE_TWO_AND_HALF_SECONDS
			if distance <= DISTANCE_ONE_AND_HALF_SECOND:
				return 1.5 * distance /DISTANCE_ONE_AND_HALF_SECOND
			elif distance <= DISTANCE_TWO_SECONDS:
				return 1.5 + ((distance- DISTANCE_ONE_AND_HALF_SECOND) * 0.5 / (DISTANCE_TWO_SECONDS-DISTANCE_ONE_AND_HALF_SECOND))
		
		def getDistanceToObject(objectName):
			global objects
			obPosition = {}
			if objects[objectName]:
				obPosition = objects[objectName]
			
			if 'x' in obPosition and 'z' in obPosition:
				x = abs(dronePosition['x'] - obPosition['x'])
				y = abs(dronePosition['y'] - obPosition['y'])
				
				return {
					'x': math.sqrt( x*x + y*y ),
					'z': getDistance(dronePosition['z'], obPosition['z'])
				}
			else:
				return {'x': 0, 'z': 0}
				
				
		def getDistance(dronePos, obPos):
		  if dronePos > obPos:
		    return - abs(dronePos - obPos);
		  else:
		    return abs(dronePos - obPos);
		
		
		def getRotationToObject(objectName):
			global objects
			obPosition = {}
			if objects[objectName]:
				obPosition = objects[objectName]
				
			if 'x' in obPosition and 'z' in obPosition:
				angleToObject = math.atan2(dronePosition['x'] - obPosition['x'], dronePosition['y'] - obPosition['y']) * 180 / math.pi
				
				angleToObject = angleTo360(angleToObject)
				isPositive = True;
				if currentDroneAngle > angleToObject:
					isPositive = False
					
				angleToObject = abs(currentDroneAngle - angleToObject)
				
				if angleToObject > 180:
					angleToObject = 360 - angleToObject;
					isPositive = not isPositive;
				
				return angleToObject if isPositive else -angleToObject
			else:
				return 0
		
		def angleTo360(angle):
		  while angle < 0:
		    angle = 360 + angle
		  return angle		
			
		def oppositeSigns(x, y): 
			return (x < 0) if (y >= 0) else (y < 0)

		mamboAddr = "e0:14:55:b4:3d:a9"

		drone = Mambo(mamboAddr)

		print("Attempting connection...")
		success = drone.connect(num_retries=3)
		
		if not success:
			print("Connection failed :'(")
			exit()

		#Main	
		«FOR to : main.fly.takeoff»  
		drone.safe_takeoff(3)
		«ENDFOR»
		
		«FOR f : main.fly.commands»
			«IF f instanceof Command»
				«f.compile»
			«ENDIF»
		«ENDFOR»
		
		«FOR to : main.fly.land»  
		drone.safe_land(3)
		«ENDFOR»
		drone.disconnect()
	'''
	
	def compile(Command cmd) '''
		«IF cmd instanceof Up »
		print("Up unsupported")
	  	«ENDIF»
	  	«IF cmd instanceof Down»
		print("Down unsupported")
	  	«ENDIF»
	  	«IF cmd instanceof Left »
		drone.fly_direct(-10, 0, 0, 0, «cmd.distance»)
	  	«ENDIF»
	  	«IF cmd instanceof Right»
		drone.fly_direct(10, 0, 0, 0, «cmd.distance»)
	  	«ENDIF»
	  	«IF cmd instanceof Forward»
		drone.fly_direct(0, 10, 0, 0, «cmd.distance»)
	  	«ENDIF»
	  	«IF cmd instanceof Backward»
		drone.fly_direct(0, -10, 0, 0, «cmd.distance»)
	  	«ENDIF»
	  	«IF cmd instanceof Wait»
		drone.smart_sleep(«cmd.seconds»)
	  	«ENDIF» 	
	  	«IF cmd instanceof RotateL»
		drone.turn_degrees(-«cmd.angle»)
	  	«ENDIF»
	  	«IF cmd instanceof RotateR»
		drone.turn_degrees(«cmd.angle»)
	  	«ENDIF»
	  	«IF cmd instanceof GoTo»
		print("GoTo unsupported")
		«ENDIF»
	'''

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var result = "";
		var time = System.currentTimeMillis(); //Replace with "" if running tests
		var localJS = "Webroot"; //use if run locally
		var warFileJS = "/opt/tomcat/8_0/webapps/ROOT" //use if building a war file
		var localPython = "WebRoot/result.py"; //use if run locally
		var warFilePython = "/xdrone/result.py" //use if building a war file
		
		//Generating python script which controls AR Drone
		for(main : resource.allContents.toIterable.filter(Main)) {
			result = main.compilePython.toString; 
			fsa.generateFile(localPython, result); //If building a warfile change to warFilePython
		}
		
		try {
			var file = new File(localPython); //If building a warfile change to warFilePython
			file.getParentFile().mkdirs();
			
			var writer = new PrintWriter(file, "UTF-8");
		    writer.println(result);
		    writer.close();   
		} catch (IOException e) {
		   // do something
		}

		
		//FLying commands for controlling drone in simulator
		result = "";
		for(fly : resource.allContents.toIterable.filter(Fly)) {
			result = fly.compileJS.toString; 
			fsa.generateFile(localJS+'/simulator' + time +'.js', result); //If building a warfile change to warFileJS
		}
		
		try {
			var file = new File(localJS+'/simulator' + time +'.js');//If building a warfile change to warFileJS
			file.getParentFile().mkdirs();
			
			var writer = new PrintWriter(file, "UTF-8");
		    writer.println(result);
		    writer.close();   
		} catch (IOException e) {
		   // do something
		}
		
		
		//Script with objects mapped to the simulator
		result = "";
		for(environment : resource.allContents.toIterable.filter(Environment)) {
			result = environment.compile.toString; 
			fsa.generateFile(localJS+'/environment' + time +'.js', result); //If building a warfile change to warFileJS
		}
		
		try {
			var file = new File(localJS+'/environment' + time +'.js'); //If building a warfile change to warFileJS
			file.getParentFile().mkdirs();
			
			var writer = new PrintWriter(file, "UTF-8");
		    writer.println(result);
		    writer.close();   
		} catch (IOException e) {
		   // do something
		}
		
	}
}